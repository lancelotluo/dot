digraph {
    "ngx_http_quic_send_chain入口函数"[fillcolor=red, style=filled];
    "if ((buf_len == 0 || in->buf->in_file || in->buf->last_in_chain) && in->buf->last_buf)"[shape=diamond];
    "if (in->buf->in_file)"[shape=diamond];

    "ngx_http_quic_send_chain入口函数"->"while (in)循环"[style=dashed, color=red];
    "while (in)循环" -> "buf_len = ngx_buf_size(in->buf)"[color=red, style=dashed];
    "buf_len = ngx_buf_size(in->buf)"->"if ((buf_len == 0 || in->buf->in_file || in->buf->last_in_chain) && in->buf->last_buf)"[color=red];
    "if ((buf_len == 0 || in->buf->in_file || in->buf->last_in_chain) && in->buf->last_buf)"->"last=1"[label=Y];
    "if ((buf_len == 0 || in->buf->in_file || in->buf->last_in_chain) && in->buf->last_buf)"->"if (in->buf->in_file)"[label=N];
    "last=1"->"if (in->buf->in_file)"[label=N];
    "if (in->buf->in_file)"->"file_buf = ngx_alloc(buf_len, r->connection->log)"[label=Y];
    "file_buf = ngx_alloc(buf_len, r->connection->log)"->"n = read(in->buf->file->fd, file_buf, buf_len)";
    "n = read(in->buf->file->fd, file_buf, buf_len)"->"int ngx_http_quic_response_body_available(void *stream, unsigned char *buf, const int buf_len, int last_buf, int stream_id)";
    "int ngx_http_quic_response_body_available(void *stream, unsigned char *buf, const int buf_len, int last_buf, int stream_id)"->"free(file_buf)";
    "free(file_buf)"->"if (in->buf->in_file)";
    "if (in->buf->in_file)"->"int ngx_http_quic_response_body_available(void *stream, unsigned char *buf, const int buf_len, int last_buf, int stream_id)"[label=N];
    "int ngx_http_quic_response_body_available(void *stream, unsigned char *buf, const int buf_len, int last_buf, int stream_id)"->"in = in->next"[color=red];
    "in = in->next"->"while (in)循环"[color=red, style=dashed];
    "while (in)循环"->"return in"[color=red];
    "return in"->"ngx_http_quic_send_chain入口函数"[color=red, style=dashed];


subgraph cluster_ngx_http_quic_response_body_available {
    "int ngx_http_quic_response_body_available(void *stream, unsigned char *buf, const int buf_len, int last_buf, int stream_id)"->"string ngx_body = string(reinterpret_cast<char*>(buf), buf_len)"[style=dashed];
    "string ngx_body = string(reinterpret_cast<char*>(buf), buf_len)"->"quic_stream->OnNginxBodyAvailable(ngx_body, fin)";
    "quic_stream->OnNginxBodyAvailable(ngx_body, fin)"->"return 0";
    "return 0"->"int ngx_http_quic_response_body_available(void *stream, unsigned char *buf, const int buf_len, int last_buf, int stream_id)"[style=dashed];
}

subgraph cluster_stream_OnNginxBodyAvailable {
    "quic_stream->OnNginxBodyAvailable(ngx_body, fin)"->"void QuicSimpleServerStream::OnNginxBodyAvailable(const std::string &body, bool fin)"[dir=both, style=dashed];
    "void QuicSimpleServerStream::OnNginxBodyAvailable(const std::string &body, bool fin)"->"if (write_side_closed() || fin_buffered()"[style=dashed];
    "if (write_side_closed() || fin_buffered()"->"return;"[label=Y];
    "if (write_side_closed() || fin_buffered()"->"WriteOrBufferData(body, fin, nullptr)"[label=N];
    "return;"->"WriteOrBufferData(body, fin, nullptr)";
    "WriteOrBufferData(body, fin, nullptr)"->"void QuicSimpleServerStream::OnNginxBodyAvailable(const std::string &body, bool fin)"[style=dashed];
}

subgraph cluster_QuicStream_WriteOrBufferData {
    "if (data.length() > 0)"[shape=diamond];
    "if (!had_buffered_data && (HasBufferedData() || fin_buffered_))"[shape=diamond];

    "WriteOrBufferData(body, fin, nullptr)"->"void QuicStream::WriteOrBufferData"[dir=both, style=dashed];
    "void QuicStream::WriteOrBufferData"->"if (data.length() > 0)"[style=dashed];
    "if (data.length() > 0)"->"struct iovec iov(MakeIovec(data))"[label=Y];
    "struct iovec iov(MakeIovec(data))"->"send_buffer_.SaveStreamData(&iov, 1, 0, data.length())";
    "send_buffer_.SaveStreamData(&iov, 1, 0, data.length())"->"OnDataBuffered(offset, data.length(), ack_listener)";
    "OnDataBuffered(offset, data.length(), ack_listener)"->"if (!had_buffered_data && (HasBufferedData() || fin_buffered_))";

    "if (data.length() > 0)"->"if (!had_buffered_data && (HasBufferedData() || fin_buffered_))"[label=N];

    "if (!had_buffered_data && (HasBufferedData() || fin_buffered_))"->"WriteBufferedData()"[label=Y];
    "if (!had_buffered_data && (HasBufferedData() || fin_buffered_))"->"void QuicStream::WriteOrBufferData"[label=N, style=dashed];
    "WriteBufferedData()"->"void QuicStream::WriteOrBufferData"[style=dashed];

    "WriteBufferedData()"->"void QuicStream::WriteBufferedData"[style=dashed, dir=both];
}

subgraph cluster_QuicStreamSendBuffer_SaveStreamData {
    label="void QuicStreamSendBuffer::SaveStreamData
    用于将nginx body数据切分成iovec，用于stream发送"


    "send_buffer_.SaveStreamData(&iov, 1, 0, data.length())"->
    "void QuicStreamSendBuffer::SaveStreamData"[dir=both, style=dashed];
    "void QuicStreamSendBuffer::SaveStreamData"->
    " const QuicByteCount max_data_slice_size =
    GetQuicFlag(FLAGS_quic_send_buffer_max_data_slice_size)
    max_data_slice_size这个值等于4096";
    " const QuicByteCount max_data_slice_size =
    GetQuicFlag(FLAGS_quic_send_buffer_max_data_slice_size)
    max_data_slice_size这个值等于4096"->
    "while (data_length > 0) {
        size_t slice_len = std::min(data_length, max_data_slice_size);
    QuicMemSlice slice(allocator_, slice_len);
    QuicUtils::CopyToBuffer(iov, iov_count, iov_offset, slice_len,
                            const_cast<char*>(slice.data()));
    SaveMemSlice(std::move(slice));
    data_length -= slice_len;
    iov_offset += slice_len;
  }"
    "while (data_length > 0) {
        size_t slice_len = std::min(data_length, max_data_slice_size);
    QuicMemSlice slice(allocator_, slice_len);
    QuicUtils::CopyToBuffer(iov, iov_count, iov_offset, slice_len,
                            const_cast<char*>(slice.data()));
    SaveMemSlice(std::move(slice));
    data_length -= slice_len;
    iov_offset += slice_len;
  }"->"void QuicStreamSendBuffer::SaveStreamData"[style=dashed];
}

subgraph cluster_QuicStream_WriteBufferedData {

    "if (session_->ShouldYield(id()))"[shape=diamond];
    "QuicConsumedData consumed_data = 
        WritevDataInner(write_length, stream_bytes_written(), fin)"[style=filled, fillcolor=gold];

    "void QuicStream::WriteBufferedData"->"if (session_->ShouldYield(id()))"[style=dashed];
    "if (session_->ShouldYield(id()))"->"session_->MarkConnectionLevelWriteBlocked(id())"[label=Y];
    "session_->MarkConnectionLevelWriteBlocked(id())"->"void QuicStream::WriteBufferedData"[style=dashed, label="return"];

    "if (session_->ShouldYield(id()))"->
    "size_t write_length = BufferedDataBytes();
    bool fin_with_zero_data = (fin_buffered_ && write_length == 0);
    bool fin = fin_buffered_;"[label=N];
    "size_t write_length = BufferedDataBytes();
    bool fin_with_zero_data = (fin_buffered_ && write_length == 0);
    bool fin = fin_buffered_;"->
    "send_window = flow_controller_.SendWindowSize();
    初始值是kMinimumFlowControlSendWindow=16K，发送数据时为6*1024*1024";
    "send_window = flow_controller_.SendWindowSize();
    初始值是kMinimumFlowControlSendWindow=16K，发送数据时为6*1024*1024"->
    "if (stream_contributes_to_connection_flow_control_) { 
    send_window =
        std::min(send_window, connection_flow_controller_->SendWindowSize());
    }";
    "if (stream_contributes_to_connection_flow_control_) { 
    send_window =
        std::min(send_window, connection_flow_controller_->SendWindowSize());
    }"->
    "if (session_->session_decides_what_to_write()) {
        session_->SetTransmissionType(NOT_RETRANSMISSION);
    }";
    "if (session_->session_decides_what_to_write()) {
        session_->SetTransmissionType(NOT_RETRANSMISSION);
    }"->
    "QuicConsumedData consumed_data = 
        WritevDataInner(write_length, stream_bytes_written(), fin)";
    "QuicConsumedData consumed_data = 
        WritevDataInner(write_length, stream_bytes_written(), fin)"->
    "OnStreamDataConsumed(consumed_data.bytes_consumed)";
    "OnStreamDataConsumed(consumed_data.bytes_consumed)"->
    "AddBytesSent(consumed_data.bytes_consumed)";
    "AddBytesSent(consumed_data.bytes_consumed)"->
    "if (write_side_closed_) {
         return;
    }";
    "if (write_side_closed_) {
         return;
    }"->
    "  if (consumed_data.bytes_consumed == write_length) {
    if (!fin_with_zero_data) {
      MaybeSendBlocked();
    }   
    if (fin && consumed_data.fin_consumed) {
      fin_sent_ = true;
      fin_outstanding_ = true;
      if (fin_received_) {
        session_->StreamDraining(id_);
      }   
      CloseWriteSide();
    } else if (fin && !consumed_data.fin_consumed) {
      session_->MarkConnectionLevelWriteBlocked(id());
    }   
  } else {
    session_->MarkConnectionLevelWriteBlocked(id());
  }
  if (consumed_data.bytes_consumed > 0 || consumed_data.fin_consumed) {
    busy_counter_ = 0;
  }";
    "  if (consumed_data.bytes_consumed == write_length) {
    if (!fin_with_zero_data) {
      MaybeSendBlocked();
    }   
    if (fin && consumed_data.fin_consumed) {
      fin_sent_ = true;
      fin_outstanding_ = true;
      if (fin_received_) {
        session_->StreamDraining(id_);
      }   
      CloseWriteSide();
    } else if (fin && !consumed_data.fin_consumed) {
      session_->MarkConnectionLevelWriteBlocked(id());
    }   
  } else {
    session_->MarkConnectionLevelWriteBlocked(id());
  }
  if (consumed_data.bytes_consumed > 0 || consumed_data.fin_consumed) {
    busy_counter_ = 0;
  }"->
   "void QuicStream::WriteBufferedData"[style=dashed];
}

subgraph cluster_QuicStream_WritevDataInner {

    "QuicConsumedData consumed_data = 
        WritevDataInner(write_length, stream_bytes_written(), fin)"->
    "QuicConsumedData QuicStream::WritevDataInner(size_t write_length,
     QuicStreamOffset offset, bool fin)"[dir=both, style=dashed];

    "QuicConsumedData QuicStream::WritevDataInner(size_t write_length,
     QuicStreamOffset offset, bool fin)"->
    "if (fin && add_random_padding_after_fin_) { 
        state = FIN_AND_PADDING;
    }"[style=dashed];

    "if (fin && add_random_padding_after_fin_) { 
        state = FIN_AND_PADDING;
    }"->
    "return session()->WritevData(this, id(), write_length, offset, state);";

    "return session()->WritevData(this, id(), write_length, offset, state);"->
    "QuicConsumedData consumed_data = 
        WritevDataInner(write_length, stream_bytes_written(), fin)"[style=dashed];
    
}


    subgraph cluster_QuicSession_WritevData {
    label = "QuicSession::WritevData";
    "QuicConsumedData QuicSession::WritevData"[style=filled, fillcolor=gold];
    
    "if (!IsEncryptionEstablished() && id != kCryptoStreamId)"[shape=diamond];
    "if (id == kCryptoStreamId && stream != GetMutableCryptoStream())"[shape=diamond];

    "return session()->WritevData(this, id(), write_length, offset, state);"->
    "QuicConsumedData QuicSession::WritevData"[dir=both, style=dashed];
    "QuicConsumedData QuicSession::WritevData"->"if (id == kCryptoStreamId && stream != GetMutableCryptoStream())"[style=dashed];
    "if (id == kCryptoStreamId && stream != GetMutableCryptoStream())"->
    "QuicConsumedData QuicSession::WritevData"[label="Y  return QuicConsumedData(0, false)",style=dashed];
    "if (id == kCryptoStreamId && stream != GetMutableCryptoStream())"->
    "if (!IsEncryptionEstablished() && id != kCryptoStreamId)"[label=N];
    "if (!IsEncryptionEstablished() && id != kCryptoStreamId)"->
    "QuicConsumedData QuicSession::WritevData"[label="Y  return QuicConsumedData(0, false)",style=dashed];
    "if (!IsEncryptionEstablished() && id != kCryptoStreamId)"->
    "QuicConsumedData data = 
    connection_->SendStreamData(id, write_length, offset, state)"[label=N];
    "QuicConsumedData data = 
    connection_->SendStreamData(id, write_length, offset, state)"->
    "QuicSession::WritevData return data;";
    "QuicSession::WritevData return data;"->"QuicConsumedData QuicSession::WritevData"[style=dashed];
    }   

    subgraph cluster_QuicConnection_SendStreamData{
    label="QuicConnection::SendStreamData";
    "if (state == NO_FIN && write_length == 0)"[shape=diamond];

    "QuicConsumedData data = 
    connection_->SendStreamData(id, write_length, offset, state)"->
    "QuicConnection::SendStreamData"[dir=both, style=dashed];
    "QuicConnection::SendStreamData"->"if (state == NO_FIN && write_length == 0)"[style=dashed];
    "if (state == NO_FIN && write_length == 0)"->"QuicConnection::SendStreamData"[label="Y return QuicConsumedData(0, false);", style=dashed];
    "if (state == NO_FIN && write_length == 0)"->"ScopedRetransmissionScheduler alarm_delayer(this)"[label=N];
    "ScopedRetransmissionScheduler alarm_delayer(this)"->"ScopedPacketFlusher flusher(this, SEND_ACK_IF_PENDING)";
    "ScopedPacketFlusher flusher(this, SEND_ACK_IF_PENDING)"->"packet_generator_.ConsumeData(id, write_length, offset, state)";
    "packet_generator_.ConsumeData(id, write_length, offset, state)"->"QuicConnection::SendStreamData"[style=dashed];
    }   

    subgraph cluster_QuicPacketGenerator_ConsumeData {
    label = "QuicPacketGenerator::ConsumeData";
    "// We determine if we can enter the fast path before executing
     // the slow path loop.
    bool run_fast_path = !has_handshake && state != FIN_AND_PADDING &&
                       !HasQueuedFrames() &&
                       write_length - total_bytes_consumed > kMaxPacketSize;
    //快慢路径的区别是什么？"[fillcolore=gold, style=filled];
    "  while (!run_fast_path && delegate_->ShouldGeneratePacket(
                               HAS_RETRANSMITTABLE_DATA,
                               has_handshake ? IS_HANDSHAKE : NOT_HANDSHAKE))"[fillcolore=gold, style=filled];
    "packet_creator_.ConsumeData"[shape=diamond, style=filled, fillcolor=gold];

    "packet_generator_.ConsumeData(id, write_length, offset, state)"->"QuicPacketGenerator::ConsumeData"[dir=both, style=dashed];
    "packet_generator_.ConsumeData(id, write_length, offset, state)"->"QuicPacketGenerator::ConsumeData"->
    "const bool flush =
      has_handshake && packet_creator_.HasPendingRetransmittableFrames();
  SendQueuedFrames(flush);"[style=dashed];
    "const bool flush =
      has_handshake && packet_creator_.HasPendingRetransmittableFrames();
  SendQueuedFrames(flush);"->
    "  if (!packet_creator_.HasRoomForStreamFrame(id, offset, write_length)) {
    packet_creator_.Flush();}";
    "  if (!packet_creator_.HasRoomForStreamFrame(id, offset, write_length)) {
    packet_creator_.Flush();}"->
    "if (!fin && (write_length == 0)) {
    return QuicConsumedData(0, false);}";
    "if (!fin && (write_length == 0)) {
    return QuicConsumedData(0, false);}"->
    "// We determine if we can enter the fast path before executing
     // the slow path loop.
    bool run_fast_path = !has_handshake && state != FIN_AND_PADDING &&
                       !HasQueuedFrames() &&
                       write_length - total_bytes_consumed > kMaxPacketSize;
    //快慢路径的区别是什么？";
    "// We determine if we can enter the fast path before executing
     // the slow path loop.
    bool run_fast_path = !has_handshake && state != FIN_AND_PADDING &&
                       !HasQueuedFrames() &&
                       write_length - total_bytes_consumed > kMaxPacketSize;
    //快慢路径的区别是什么？"->
    "  while (!run_fast_path && delegate_->ShouldGeneratePacket(
                               HAS_RETRANSMITTABLE_DATA,
                               has_handshake ? IS_HANDSHAKE : NOT_HANDSHAKE))";
    "  while (!run_fast_path && delegate_->ShouldGeneratePacket(
                               HAS_RETRANSMITTABLE_DATA,
                               has_handshake ? IS_HANDSHAKE : NOT_HANDSHAKE))"->
    "packet_creator_.ConsumeData"[style=dashed];
    "packet_creator_.ConsumeData"->"QuicPacketGenerator::ConsumeData"[label="N return QuicConsumedData(0, false)", style=dashed];
    "packet_creator_.ConsumeData"->"packet_creator_.Flush()"[label=Y];
    "packet_creator_.Flush()"->
    "run_fast_path = !has_handshake && state != FIN_AND_PADDING &&
                    !HasQueuedFrames() &&
                    write_length - total_bytes_consumed > kMaxPacketSize;"
    "run_fast_path = !has_handshake && state != FIN_AND_PADDING &&
                    !HasQueuedFrames() &&
                    write_length - total_bytes_consumed > kMaxPacketSize;"->
    "  while (!run_fast_path && delegate_->ShouldGeneratePacket(
                               HAS_RETRANSMITTABLE_DATA,
                               has_handshake ? IS_HANDSHAKE : NOT_HANDSHAKE))"[style=dashed];
    "  while (!run_fast_path && delegate_->ShouldGeneratePacket(
                               HAS_RETRANSMITTABLE_DATA,
                               has_handshake ? IS_HANDSHAKE : NOT_HANDSHAKE))"->
    "  if (run_fast_path) {
    return ConsumeDataFastPath(id, write_length, offset, state != NO_FIN,
                               total_bytes_consumed);"
    "  if (run_fast_path) {
    return ConsumeDataFastPath(id, write_length, offset, state != NO_FIN,
                               total_bytes_consumed);"->
    "  if (has_handshake) {
    SendQueuedFrames(/*flush=*/true);}";
    "  if (has_handshake) {
    SendQueuedFrames(/*flush=*/true);}"->"QuicPacketGenerator::ConsumeData"[style=dashed, label="return QuicConsumedData(total_bytes_consumed, fin_consumed);"];

}
subgraph cluster_{
    label="QuicPacketGenerator::ConsumeDataFastPath(
        QuicStreamId id, 
    size_t write_length,
    QuicStreamOffset offset,
    bool fin,
    size_t total_bytes_consumed)
    其中write_length表示可以送的最大数据，受限于发送窗口. 
    offset表示stream中的偏移
    ";

    "QuicConsumedData QuicPacketGenerator::ConsumeDataFastPath"[style=filled, fillcolor=gold];

    "  if (run_fast_path) {
    return ConsumeDataFastPath(id, write_length, offset, state != NO_FIN,
                               total_bytes_consumed);"->
    "QuicConsumedData QuicPacketGenerator::ConsumeDataFastPath"[dir=both, style=dashed];
    "QuicConsumedData QuicPacketGenerator::ConsumeDataFastPath"->
    "  while (total_bytes_consumed < write_length &&
         delegate_->ShouldGeneratePacket(HAS_RETRANSMITTABLE_DATA,
                                         NOT_HANDSHAKE)) {
    // Serialize and encrypt the packet.
    size_t bytes_consumed = 0;
    packet_creator_.CreateAndSerializeStreamFrame(
        id, write_length, total_bytes_consumed, offset + total_bytes_consumed,
        fin, &bytes_consumed);
    total_bytes_consumed += bytes_consumed;
  }"[style=dashed];
    "  while (total_bytes_consumed < write_length &&
         delegate_->ShouldGeneratePacket(HAS_RETRANSMITTABLE_DATA,
                                         NOT_HANDSHAKE)) {
    // Serialize and encrypt the packet.
    size_t bytes_consumed = 0;
    packet_creator_.CreateAndSerializeStreamFrame(
        id, write_length, total_bytes_consumed, offset + total_bytes_consumed,
        fin, &bytes_consumed);
    total_bytes_consumed += bytes_consumed;
  }"->
    "  return QuicConsumedData(total_bytes_consumed,
                          fin && (total_bytes_consumed == write_length));"[style=dashed];
    "  return QuicConsumedData(total_bytes_consumed,
                          fin && (total_bytes_consumed == write_length));"->
    "QuicConsumedData QuicPacketGenerator::ConsumeDataFastPath"[style=dashed];
}

subgraph cluster_QuicConnection_ShouldGeneratePacket{
    label="bool QuicConnection::ShouldGeneratePacket";

    "  while (!run_fast_path && delegate_->ShouldGeneratePacket(
                               HAS_RETRANSMITTABLE_DATA,
                               has_handshake ? IS_HANDSHAKE : NOT_HANDSHAKE))"
    ->"bool QuicConnection::ShouldGeneratePacket"[dir=both, style=dashed];
    "bool QuicConnection::ShouldGeneratePacket"->
    " if (handshake == IS_HANDSHAKE) {
        return true;
    }"[style=dashed];
    " if (handshake == IS_HANDSHAKE) {
        return true;
    }"->
    "return CanWrite(retransmittable);";
    "return CanWrite(retransmittable);"->"bool QuicConnection::ShouldGeneratePacket"[style=dashed];
}
subgraph cluster_QuicConnection_CanWrite{
    label="bool QuicConnection::CanWrite";
    "bool QuicConnection::CanWrite"[style=filled, fillcolor=gold];

    "return CanWrite(retransmittable);"->"bool QuicConnection::CanWrite"[style=dashed, dir=both];
    "bool QuicConnection::CanWrite"->
    "  if (!connected_) {
    return false;
  }";
    "  if (!connected_) {
    return false;
  }"->
    "  if (session_decides_what_to_write() &&
      sent_packet_manager_.pending_timer_transmission_count() > 0) { 
    // Force sending the retransmissions for HANDSHAKE, TLP, RTO, PROBING cases.
    return true;
  }";
    "  if (session_decides_what_to_write() &&
      sent_packet_manager_.pending_timer_transmission_count() > 0) { 
    // Force sending the retransmissions for HANDSHAKE, TLP, RTO, PROBING cases.
    return true;
  }"->
    "  if (add_to_blocked_list_if_writer_blocked_) {
    if (HandleWriteBlocked()) {
      return false;
    }    
  } else {
    if (writer_->IsWriteBlocked()) {
      visitor_->OnWriteBlocked();
      return false;
    }    
  }";
    "  if (add_to_blocked_list_if_writer_blocked_) {
    if (HandleWriteBlocked()) {
      return false;
    }    
  } else {
    if (writer_->IsWriteBlocked()) {
      visitor_->OnWriteBlocked();
      return false;
    }    
  }"->
    "// Allow acks to be sent immediately.
  if (retransmittable == NO_RETRANSMITTABLE_DATA) {
    return true;
  }
  // If the send alarm is set, wait for it to fire.
  if (send_alarm_->IsSet()) {
    return false;
  }";
    "// Allow acks to be sent immediately.
  if (retransmittable == NO_RETRANSMITTABLE_DATA) {
    return true;
  }
  // If the send alarm is set, wait for it to fire.
  if (send_alarm_->IsSet()) {
    return false;
  }"->
    "QuicTime now = clock_->Now();";
    "QuicTime now = clock_->Now();"->
    "QuicTime::Delta delay = sent_packet_manager_.TimeUntilSend(now)";
    "QuicTime::Delta delay = sent_packet_manager_.TimeUntilSend(now)"->
    "  if (delay.IsInfinite()) {
    send_alarm_->Cancel();
    return false;
  }";
    "  if (delay.IsInfinite()) {
    send_alarm_->Cancel();
    return false;
  }"->
    "  // Scheduler requires a delay.
  if (!delay.IsZero()) {
    if (delay <= release_time_into_future_) {
      // Required delay is within pace time into future, send now.
      return true;
    }    
    // Cannot send packet now because delay is too far in the future.
    send_alarm_->Update(now + delay, QuicTime::Delta::FromMilliseconds(1));
    return false;
  }";
    "  // Scheduler requires a delay.
  if (!delay.IsZero()) {
    if (delay <= release_time_into_future_) {
      // Required delay is within pace time into future, send now.
      return true;
    }    
    // Cannot send packet now because delay is too far in the future.
    send_alarm_->Update(now + delay, QuicTime::Delta::FromMilliseconds(1));
    return false;
  }"->"bool QuicConnection::CanWrite"[label=true, style=dashed];

}
    subgraph cluster_QuicSentPacketManager_TimeUntilSend{
    label="QuicTime::Delta QuicSentPacketManager::TimeUntilSend";
    "QuicTime::Delta delay = sent_packet_manager_.TimeUntilSend(now)"->"QuicTime::Delta QuicSentPacketManager::TimeUntilSend"[dir=both, style=dashed];
    "QuicTime::Delta QuicSentPacketManager::TimeUntilSend"->
    "  if (pending_timer_transmission_count_ > 0) {
    return QuicTime::Delta::Zero();
  }"[style=dashed];
    "  if (pending_timer_transmission_count_ > 0) {
    return QuicTime::Delta::Zero();
  }"->
    "  if (using_pacing_) {
    return pacing_sender_.TimeUntilSend(now,
                                        unacked_packets_.bytes_in_flight());
    }";
    "  if (using_pacing_) {
    return pacing_sender_.TimeUntilSend(now,
                                        unacked_packets_.bytes_in_flight());
    }"->
    "  return send_algorithm_->CanSend(unacked_packets_.bytes_in_flight())
             ? QuicTime::Delta::Zero()
             : QuicTime::Delta::Infinite();";
    "  return send_algorithm_->CanSend(unacked_packets_.bytes_in_flight())
             ? QuicTime::Delta::Zero()
             : QuicTime::Delta::Infinite();"->"QuicTime::Delta QuicSentPacketManager::TimeUntilSend"[style=dashed];
}

subgraph cluster_QuicSentPacketManager_TimeUntilSend{
    label="QuicTime::Delta PacingSender::TimeUntilSend";
    "!sender_->CanSend(bytes_in_flight)"[shape=diamond, style=filled, fillcolor=gold];
    
    "  if (using_pacing_) {
    return pacing_sender_.TimeUntilSend(now,
                                        unacked_packets_.bytes_in_flight());
    }"->
    "QuicTime::Delta PacingSender::TimeUntilSend"[style=dashed, dir=both];
    "QuicTime::Delta PacingSender::TimeUntilSend"->
    "!sender_->CanSend(bytes_in_flight)"[style=dashed];
    "!sender_->CanSend(bytes_in_flight)"->"QuicTime::Delta PacingSender::TimeUntilSend"[label="Y && return QuicTime::Delta::Infinite()", style=dashed];
    "!sender_->CanSend(bytes_in_flight)"->
    "  if (burst_tokens_ > 0 || bytes_in_flight == 0 || lumpy_tokens_ > 0) {
    // Don't pace if we have burst tokens available or leaving quiescence.
    return QuicTime::Delta::Zero();
  }"[label=N];
    "  if (burst_tokens_ > 0 || bytes_in_flight == 0 || lumpy_tokens_ > 0) {
    // Don't pace if we have burst tokens available or leaving quiescence.
    return QuicTime::Delta::Zero();
  }"->
    "  if (ideal_next_packet_send_time_ > now + alarm_granularity_) {
    return ideal_next_packet_send_time_ - now;
  }";
    "  if (ideal_next_packet_send_time_ > now + alarm_granularity_) {
    return ideal_next_packet_send_time_ - now;
  }"->"QuicTime::Delta PacingSender::TimeUntilSend"[label=" return QuicTime::Delta::Zero()"];

}

subgraph cluster_TcpCubicSenderBytes_CanSend{

   "!sender_->CanSend(bytes_in_flight)"->
    "virtual bool CanSend(QuicByteCount bytes_in_flight) = 0";
    "virtual bool CanSend(QuicByteCount bytes_in_flight) = 0"->
    "bool TcpCubicSenderBytes::CanSend(QuicByteCount bytes_in_flight)";
    "bool TcpCubicSenderBytes::CanSend(QuicByteCount bytes_in_flight)"->
    "  if (!no_prr_ && InRecovery()) {
    // PRR is used when in recovery.
    return prr_.CanSend(GetCongestionWindow(), bytes_in_flight,
                        GetSlowStartThreshold());
  }"[style=dashed];
    "  if (!no_prr_ && InRecovery()) {
    // PRR is used when in recovery.
    return prr_.CanSend(GetCongestionWindow(), bytes_in_flight,
                        GetSlowStartThreshold());
  }"->
    "  if (GetCongestionWindow() > bytes_in_flight) {
    return true;
  }";
    "  if (GetCongestionWindow() > bytes_in_flight) {
    return true;
  }"->
    "  if (min4_mode_ && bytes_in_flight < 4 * kDefaultTCPMSS) {
    return true;
  }";
    "  if (min4_mode_ && bytes_in_flight < 4 * kDefaultTCPMSS) {
    return true;
  }"->"bool TcpCubicSenderBytes::CanSend(QuicByteCount bytes_in_flight)"[style=dashed, label="return false"];

}
    subgraph cluster_QuicPacketCreator_ConsumeData {
    label = "bool QuicPacketCreator::ConsumeData";

    "packet_creator_.ConsumeData"->
    "bool QuicPacketCreator::ConsumeData(QuicStreamId id,
                                    size_t write_length,
                                    size_t iov_offset,
                                    QuicStreamOffset offset,
                                    bool fin,
                                    bool needs_full_padding,
                                    QuicFrame* frame)"[dir=both, style=dashed];

    }

subgraph cluster_QuicPacketCreator_Flush{
    label="void QuicPacketCreator::Flush()";
    "if (!HasPendingFrames() && pending_padding_bytes_ == 0)"[shape=diamond];
    
    "packet_creator_.Flush()"->"void QuicPacketCreator::Flush()"[dir=both, style=dashed];
    "void QuicPacketCreator::Flush()"->"if (!HasPendingFrames() && pending_padding_bytes_ == 0)"[style=dashed];
    "if (!HasPendingFrames() && pending_padding_bytes_ == 0)"->"void QuicPacketCreator::Flush()"[label="Y && return", style=dashed]
    "if (!HasPendingFrames() && pending_padding_bytes_ == 0)"->"serialized_packet_buffer = delegate_->GetPacketBuffer()"[label=N];
    "serialized_packet_buffer = delegate_->GetPacketBuffer()"->"SerializePacket(serialized_packet_buffer, kMaxPacketSize)";
    "SerializePacket(serialized_packet_buffer, kMaxPacketSize)"->"OnSerializedPacket()";
    "OnSerializedPacket()"->"void QuicPacketCreator::Flush()"[style=dashed];
}
subgraph cluster_QuicPacketCreator_SerializePacket{
    label="void QuicPacketCreator::SerializePacket";

    "SerializePacket(serialized_packet_buffer, kMaxPacketSize)"->
    "void QuicPacketCreator::SerializePacket"[dir=both, style=dashed];
    "void QuicPacketCreator::SerializePacket"->"FillPacketHeader(&header)"[style=dashed];
    "FillPacketHeader(&header)"->"MaybeAddPadding()";
    "MaybeAddPadding()"->
    "framer_->BuildDataPacket(header, queued_frames_,
    encrypted_buffer, packet_size_)";
    "framer_->BuildDataPacket(header, queued_frames_,
    encrypted_buffer, packet_size_)"->
    "encrypted_length = framer_->EncryptInPlace(
    packet_.encryption_level, packet_.packet_number,
    GetStartOfEncryptedData(framer_->transport_version(), header), length,
    encrypted_buffer_len, encrypted_buffer)";
    "encrypted_length = framer_->EncryptInPlace(
    packet_.encryption_level, packet_.packet_number,
    GetStartOfEncryptedData(framer_->transport_version(), header), length,
    encrypted_buffer_len, encrypted_buffer)"->"queued_frames_.clear()";
    "queued_frames_.clear()"->
    "packet_.encrypted_buffer = encrypted_buffer;
    packet_.encrypted_length = encrypted_length;";
    "packet_.encrypted_buffer = encrypted_buffer;
    packet_.encrypted_length = encrypted_length;"->
    "void QuicPacketCreator::SerializePacket"[style=dashed];

}
subgraph cluster_QuicPacketCreator_OnSerializedPacket {
    "OnSerializedPacket()"->
    "void QuicPacketCreator::OnSerializedPacket()"[dir=both, style=dashed];
    
    "void QuicPacketCreator::OnSerializedPacket()"->"SerializedPacket packet(std::move(packet_))"[style=dashed];
    "SerializedPacket packet(std::move(packet_))"->"ClearPacket()";
    "ClearPacket()"->"delegate_->OnSerializedPacket(&packet)";
    "delegate_->OnSerializedPacket(&packet)"->"void QuicPacketCreator::OnSerializedPacket()"[style=dashed];
}

subgraph cluster_QuicConnection_OnSerializedPacket {
    label="void QuicConnection::OnSerializedPacket";
    "delegate_->OnSerializedPacket(&packet)"->"void QuicConnection::OnSerializedPacket"[style=dashed, dir=both];
    "void QuicConnection::OnSerializedPacket"->"SendOrQueuePacket(serialized_packet)"[style=dashed];
    "SendOrQueuePacket(serialized_packet)"->"void QuicConnection::OnSerializedPacket"[style=dashed];
}
subgraph cluster_QuicConnection_SendOrQueuePacket {
    label="void QuicConnection::SendOrQueuePacket";
    "if (!queued_packets_.empty() || !WritePacket(packet))"[shape=diamond];

    "SendOrQueuePacket(serialized_packet)"->"void QuicConnection::SendOrQueuePacket"[style=dashed, dir=both];
    "void QuicConnection::SendOrQueuePacket"->"if (!queued_packets_.empty() || !WritePacket(packet))"[style=dashed];
    "if (!queued_packets_.empty() || !WritePacket(packet))"->"packet->encrypted_buffer = CopyBuffer(*packet)"[label=Y];
    "packet->encrypted_buffer = CopyBuffer(*packet)"->"queued_packets_.push_back(*packet)";
    "queued_packets_.push_back(*packet)"->"packet->retransmittable_frames.clear()";
    "packet->retransmittable_frames.clear()"->"ClearSerializedPacket(packet)";
    "if (!queued_packets_.empty() || !WritePacket(packet))"->"ClearSerializedPacket(packet)"[label=N];
    "ClearSerializedPacket(packet)"->"void QuicConnection::SendOrQueuePacket"[style=dashed];
}

subgraph cluster_QuicConnection_WritePacket{
    label="bool QuicConnection::WritePacket(SerializedPacket* packet)";
    
    "if (!queued_packets_.empty() || !WritePacket(packet))"->
    "bool QuicConnection::WritePacket(SerializedPacket* packet)"[dir=both, style=dashed];
    "bool QuicConnection::WritePacket(SerializedPacket* packet)"->
    "  if (ShouldDiscardPacket(*packet)) {
    ++stats_.packets_discarded;
    return true;
    }"[style=dashed];
    "  if (ShouldDiscardPacket(*packet)) {
    ++stats_.packets_discarded;
    return true;
    }"->
    "  if (packet->packet_number < sent_packet_manager_.GetLargestSentPacket()) {
    RecordInternalErrorLocation(QUIC_CONNECTION_WRITE_PACKET);
    return true;
    }";
    "  if (packet->packet_number < sent_packet_manager_.GetLargestSentPacket()) {
    RecordInternalErrorLocation(QUIC_CONNECTION_WRITE_PACKET);
    return true;
    }"->
    "  const bool is_termination_packet = IsTerminationPacket(*packet);
  if (HandleWriteBlocked() && !is_termination_packet) {
    return false;
  }";
    "  const bool is_termination_packet = IsTerminationPacket(*packet);
  if (HandleWriteBlocked() && !is_termination_packet) {
    return false;
  }"->
    "  // Measure the RTT from before the write begins to avoid underestimating the
  // min_rtt_, especially in cases where the thread blocks or gets swapped out
  // during the WritePacket below.
  QuicTime packet_send_time = clock_->Now();
  if (supports_release_time_ && per_packet_options_ != nullptr) {
    QuicTime next_release_time = sent_packet_manager_.GetNextReleaseTime();
    uint64_t release_time_delay_ns = 0;
    QuicTime now = packet_send_time;
    if (next_release_time > now) {
      release_time_delay_ns = (next_release_time - now).ToMicroseconds() * 1000;
      // Set packet_send_time to the future to make the RTT estimation accurate.
      packet_send_time = next_release_time;
    }
    per_packet_options_->SetReleaseTimeDelay(release_time_delay_ns);
  }";
    "  // Measure the RTT from before the write begins to avoid underestimating the
  // min_rtt_, especially in cases where the thread blocks or gets swapped out
  // during the WritePacket below.
  QuicTime packet_send_time = clock_->Now();
  if (supports_release_time_ && per_packet_options_ != nullptr) {
    QuicTime next_release_time = sent_packet_manager_.GetNextReleaseTime();
    uint64_t release_time_delay_ns = 0;
    QuicTime now = packet_send_time;
    if (next_release_time > now) {
      release_time_delay_ns = (next_release_time - now).ToMicroseconds() * 1000;
      // Set packet_send_time to the future to make the RTT estimation accurate.
      packet_send_time = next_release_time;
    }
    per_packet_options_->SetReleaseTimeDelay(release_time_delay_ns);
  }"->
    " WriteResult result = writer_->WritePacket(
      packet->encrypted_buffer, encrypted_length, self_address().host(),
      peer_address(), per_packet_options_);";
    " WriteResult result = writer_->WritePacket(
      packet->encrypted_buffer, encrypted_length, self_address().host(),
      peer_address(), per_packet_options_);"->
    "  if (result.status == WRITE_STATUS_BLOCKED) {
    // Ensure the writer is still write blocked, otherwise QUIC may continue
    // trying to write when it will not be able to.
    DCHECK(writer_->IsWriteBlocked());
    visitor_->OnWriteBlocked();
    // If the socket buffers the data, then the packet should not
    // be queued and sent again, which would result in an unnecessary
    // duplicate packet being sent.  The helper must call OnCanWrite
    // when the write completes, and OnWriteError if an error occurs.
    if (!writer_->IsWriteBlockedDataBuffered()) {
      return false;
    }
  }";
    "  if (result.status == WRITE_STATUS_BLOCKED) {
    // Ensure the writer is still write blocked, otherwise QUIC may continue
    // trying to write when it will not be able to.
    DCHECK(writer_->IsWriteBlocked());
    visitor_->OnWriteBlocked();
    // If the socket buffers the data, then the packet should not
    // be queued and sent again, which would result in an unnecessary
    // duplicate packet being sent.  The helper must call OnCanWrite
    // when the write completes, and OnWriteError if an error occurs.
    if (!writer_->IsWriteBlockedDataBuffered()) {
      return false;
    }
  }"->
    "  bool reset_retransmission_alarm = sent_packet_manager_.OnPacketSent(
      packet, packet->original_packet_number, packet_send_time,
      packet->transmission_type, IsRetransmittable(*packet));";
    "  bool reset_retransmission_alarm = sent_packet_manager_.OnPacketSent(
      packet, packet->original_packet_number, packet_send_time,
      packet->transmission_type, IsRetransmittable(*packet));"->
    "  if (reset_retransmission_alarm || !retransmission_alarm_->IsSet()) {
    SetRetransmissionAlarm();
  }";
    "  if (reset_retransmission_alarm || !retransmission_alarm_->IsSet()) {
    SetRetransmissionAlarm();
  }"->
    "  packet_generator_.UpdatePacketNumberLength(
      sent_packet_manager_.GetLeastUnacked(),
      sent_packet_manager_.EstimateMaxPacketsInFlight(max_packet_length()));";
    "  packet_generator_.UpdatePacketNumberLength(
      sent_packet_manager_.GetLeastUnacked(),
      sent_packet_manager_.EstimateMaxPacketsInFlight(max_packet_length()));"
    ->
    "  stats_.bytes_sent += result.bytes_written;
  ++stats_.packets_sent;
  if (packet->transmission_type != NOT_RETRANSMISSION) {
    stats_.bytes_retransmitted += result.bytes_written;
    ++stats_.packets_retransmitted;
  }";
    "  stats_.bytes_sent += result.bytes_written;
  ++stats_.packets_sent;
  if (packet->transmission_type != NOT_RETRANSMISSION) {
    stats_.bytes_retransmitted += result.bytes_written;
    ++stats_.packets_retransmitted;
  }"->
    "bool QuicConnection::WritePacket(SerializedPacket* packet)"[label="return true", style=dashed];
}    
subgraph cluster_QuicPerConnectionPacketWriter_WritePacket{
    " WriteResult result = writer_->WritePacket(
      packet->encrypted_buffer, encrypted_length, self_address().host(),
      peer_address(), per_packet_options_);"->
    "WriteResult QuicPerConnectionPacketWriter::WritePacket"[dir=both, style=dashed];

    "WriteResult QuicPerConnectionPacketWriter::WritePacket"->
    "return shared_writer_->WritePacket(buffer, buf_len, self_address,
        peer_address, options)"[style=dashed];
    "return shared_writer_->WritePacket(buffer, buf_len, self_address,
        peer_address, options)"->
    "WriteResult QuicPerConnectionPacketWriter::WritePacket"[style=dashed];
}
subgraph cluster_QuicDefaultPacketWriter_WritePacket {
    "return shared_writer_->WritePacket(buffer, buf_len, self_address,
        peer_address, options)"->
    "WriteResult QuicDefaultPacketWriter::WritePacket"[dir=both, style=dashed];
    "WriteResult QuicDefaultPacketWriter::WritePacket"->
    "WriteResult result = QuicSocketUtils::WritePacket"[style=dashed];
    "WriteResult result = QuicSocketUtils::WritePacket"->
    "  if (result.status == WRITE_STATUS_BLOCKED) {
    write_blocked_ = true;
    }";
    "  if (result.status == WRITE_STATUS_BLOCKED) {
    write_blocked_ = true;
    }"->
    "WriteResult QuicDefaultPacketWriter::WritePacket"[label="return result", style=dashed];

}
subgraph cluster_QuicSocketUtils_WritePacket{
    label="WriteResult QuicSocketUtils::WritePacket
    最底层的发送函数"
    style=filled;
    color=lightgrey;

    "WriteResult result = QuicSocketUtils::WritePacket"->
    "WriteResult QuicSocketUtils::WritePacket"[dir=both, style=dashed];
    "WriteResult QuicSocketUtils::WritePacket"->
    "  sockaddr_storage raw_address = peer_address.generic_address();
  iovec iov = {const_cast<char*>(buffer), buf_len};

  msghdr hdr;
  hdr.msg_name = &raw_address;
  hdr.msg_namelen = raw_address.ss_family == AF_INET ? sizeof(sockaddr_in)
                                                     : sizeof(sockaddr_in6);
  hdr.msg_iov = &iov;
  hdr.msg_iovlen = 1;
  hdr.msg_flags = 0;"[style=dashed];
    "  sockaddr_storage raw_address = peer_address.generic_address();
  iovec iov = {const_cast<char*>(buffer), buf_len};

  msghdr hdr;
  hdr.msg_name = &raw_address;
  hdr.msg_namelen = raw_address.ss_family == AF_INET ? sizeof(sockaddr_in)
                                                     : sizeof(sockaddr_in6);
  hdr.msg_iov = &iov;
  hdr.msg_iovlen = 1;
  hdr.msg_flags = 0;"->
    "  const int kSpaceForIpv4 = CMSG_SPACE(sizeof(in_pktinfo));
  const int kSpaceForIpv6 = CMSG_SPACE(sizeof(in6_pktinfo));
  // kSpaceForIp should be big enough to hold both IPv4 and IPv6 packet info.
  const int kSpaceForIp =
      (kSpaceForIpv4 < kSpaceForIpv6) ? kSpaceForIpv6 : kSpaceForIpv4;
  char cbuf[kSpaceForIp];";
    "  const int kSpaceForIpv4 = CMSG_SPACE(sizeof(in_pktinfo));
  const int kSpaceForIpv6 = CMSG_SPACE(sizeof(in6_pktinfo));
  // kSpaceForIp should be big enough to hold both IPv4 and IPv6 packet info.
  const int kSpaceForIp =
      (kSpaceForIpv4 < kSpaceForIpv6) ? kSpaceForIpv6 : kSpaceForIpv4;
  char cbuf[kSpaceForIp];"->
    "  if (!self_address.IsInitialized()) {
    hdr.msg_control = nullptr;
    hdr.msg_controllen = 0;
  } else {
    hdr.msg_control = cbuf;
    hdr.msg_controllen = kSpaceForIp;
    cmsghdr* cmsg = CMSG_FIRSTHDR(&hdr);
    SetIpInfoInCmsg(self_address, cmsg);
    hdr.msg_controllen = cmsg->cmsg_len;
  }";
    "  if (!self_address.IsInitialized()) {
    hdr.msg_control = nullptr;
    hdr.msg_controllen = 0;
  } else {
    hdr.msg_control = cbuf;
    hdr.msg_controllen = kSpaceForIp;
    cmsghdr* cmsg = CMSG_FIRSTHDR(&hdr);
    SetIpInfoInCmsg(self_address, cmsg);
    hdr.msg_controllen = cmsg->cmsg_len;
  }"->
    "  int rc; 
  do {
    rc = sendmsg(fd, &hdr, 0); 
  } while (rc < 0 && errno == EINTR);
  if (rc >= 0) {
    return WriteResult(WRITE_STATUS_OK, rc);
  }";
    "  int rc; 
  do {
    rc = sendmsg(fd, &hdr, 0); 
  } while (rc < 0 && errno == EINTR);
  if (rc >= 0) {
    return WriteResult(WRITE_STATUS_OK, rc);
  }"->
    "  return WriteResult((errno == EAGAIN || errno == EWOULDBLOCK)
                         ? WRITE_STATUS_BLOCKED
                         : WRITE_STATUS_ERROR,
                     errno);";
    "  return WriteResult((errno == EAGAIN || errno == EWOULDBLOCK)
                         ? WRITE_STATUS_BLOCKED
                         : WRITE_STATUS_ERROR,
                     errno);"->
    "WriteResult QuicSocketUtils::WritePacket"[style=dashed];

}

}

